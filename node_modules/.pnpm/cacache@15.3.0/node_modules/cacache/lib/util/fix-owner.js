'use strict'

const BB = require('bluebird')

const chownr = BB.promisify(require('chownr'))
const mkdirp = BB.promisify(require('mkdirp'))
const inflight = require('promise-inflight')

module.exports.chownr = fixOwner
function fixOwner (filepath, uid, gid) {
  if (!process.getuid) {
    // This platform doesn't need ownership fixing
    return BB.resolve()
  }
  if (typeof uid !== 'number' && typeof gid !== 'number') {
    // There's no permissions override. Nothing to do here.
    return BB.resolve()
  }
  if ((typeof uid === 'number' && process.getuid() === uid) &&
      (typeof gid === 'number' && process.getgid() === gid)) {
    // No need to override if it's already what we used.
<<<<<<< Updated upstream:node_modules/cacache/lib/util/fix-owner.js
    return BB.resolve()
  }
  return inflight(
    'fixOwner: fixing ownership on ' + filepath,
    () => chownr(
      filepath,
      typeof uid === 'number' ? uid : process.getuid(),
      typeof gid === 'number' ? gid : process.getgid()
    ).catch({ code: 'ENOENT' }, () => null)
  )
=======
    if (self.uid === uid && self.gid === gid)
      return

    return inflight('fixOwner: fixing ownership on ' + filepath, () =>
      chownr(
        filepath,
        typeof uid === 'number' ? uid : self.uid,
        typeof gid === 'number' ? gid : self.gid
      ).catch((err) => {
        if (err.code === 'ENOENT')
          return null

        throw err
      })
    )
  })
>>>>>>> Stashed changes:node_modules/.pnpm/cacache@15.3.0/node_modules/cacache/lib/util/fix-owner.js
}

module.exports.chownr.sync = fixOwnerSync
function fixOwnerSync (filepath, uid, gid) {
  if (!process.getuid) {
    // This platform doesn't need ownership fixing
    return
  }
  if (typeof uid !== 'number' && typeof gid !== 'number') {
    // There's no permissions override. Nothing to do here.
    return
  }
  if ((typeof uid === 'number' && process.getuid() === uid) &&
      (typeof gid === 'number' && process.getgid() === gid)) {
    // No need to override if it's already what we used.
    return
  }
  try {
    chownr.sync(
      filepath,
      typeof uid === 'number' ? uid : process.getuid(),
      typeof gid === 'number' ? gid : process.getgid()
    )
  } catch (err) {
<<<<<<< Updated upstream:node_modules/cacache/lib/util/fix-owner.js
    if (err.code === 'ENOENT') {
      return null
    }
=======
    // only catch ENOENT, any other error is a problem.
    if (err.code === 'ENOENT')
      return null

    throw err
>>>>>>> Stashed changes:node_modules/.pnpm/cacache@15.3.0/node_modules/cacache/lib/util/fix-owner.js
  }
}

module.exports.mkdirfix = mkdirfix
<<<<<<< Updated upstream:node_modules/cacache/lib/util/fix-owner.js
function mkdirfix (p, uid, gid, cb) {
  return mkdirp(p).then(made => {
    if (made) {
      return fixOwner(made, uid, gid).then(() => made)
    }
  }).catch({ code: 'EEXIST' }, () => {
    // There's a race in mkdirp!
    return fixOwner(p, uid, gid).then(() => null)
=======

function mkdirfix (cache, p, cb) {
  // we have to infer the owner _before_ making the directory, even though
  // we aren't going to use the results, since the cache itself might not
  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed
  // to be correct if it creates the cache folder in the process.
  return Promise.resolve(inferOwner(cache)).then(() => {
    return mkdirp(p)
      .then((made) => {
        if (made)
          return fixOwner(cache, made).then(() => made)
      })
      .catch((err) => {
        if (err.code === 'EEXIST')
          return fixOwner(cache, p).then(() => null)

        throw err
      })
>>>>>>> Stashed changes:node_modules/.pnpm/cacache@15.3.0/node_modules/cacache/lib/util/fix-owner.js
  })
}

module.exports.mkdirfix.sync = mkdirfixSync
function mkdirfixSync (p, uid, gid) {
  try {
    const made = mkdirp.sync(p)
    if (made) {
      fixOwnerSync(made, uid, gid)
      return made
    }
  } catch (err) {
    if (err.code === 'EEXIST') {
      fixOwnerSync(p, uid, gid)
      return null
    } else
      throw err
  }
}
